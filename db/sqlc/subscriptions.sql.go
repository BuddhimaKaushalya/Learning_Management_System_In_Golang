// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: subscriptions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
    user_id,
    course_id,
    active,
    pending
) VALUES (
    $1, $2, $3, $4
) RETURNING subscription_id, user_id, course_id, active, pending, created_at, updated_at
`

type CreateSubscriptionParams struct {
	UserID   int64 `json:"user_id"`
	CourseID int64 `json:"course_id"`
	Active   bool  `json:"active"`
	Pending  bool  `json:"pending"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.UserID,
		arg.CourseID,
		arg.Active,
		arg.Pending,
	)
	var i Subscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.UserID,
		&i.CourseID,
		&i.Active,
		&i.Pending,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStudentCountInCourse = `-- name: GetStudentCountInCourse :many
SELECT COUNT(DISTINCT user_id) AS Count
FROM courses
GROUP BY course_id
ORDER BY course_id
`

func (q *Queries) GetStudentCountInCourse(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getStudentCountInCourse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var count int64
		if err := rows.Scan(&count); err != nil {
			return nil, err
		}
		items = append(items, count)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscription = `-- name: GetSubscription :one
SELECT subscription_id, user_id, course_id, active, pending, created_at, updated_at FROM subscriptions
WHERE user_id = $1
`

func (q *Queries) GetSubscription(ctx context.Context, userID int64) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscription, userID)
	var i Subscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.UserID,
		&i.CourseID,
		&i.Active,
		&i.Pending,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByUser = `-- name: GetSubscriptionByUser :one
SELECT 
    s.subscription_id,
    s.user_id,
    s.course_id,
    u.user_name,
    u.first_name,
    u.last_name,
    s.active,
    s.pending,
    cp.progress,
    c.title
FROM subscriptions s
LEFT JOIN users u ON u.user_id = s.user_id
LEFT JOIN course_progress cp ON cp.user_id = s.user_id
LEFT JOIN courses c ON c.course_id = s.course_id
WHERE s.user_id = $1 AND s.course_id = $2
LIMIT 1
`

type GetSubscriptionByUserParams struct {
	UserID   int64 `json:"user_id"`
	CourseID int64 `json:"course_id"`
}

type GetSubscriptionByUserRow struct {
	SubscriptionID int64       `json:"subscription_id"`
	UserID         int64       `json:"user_id"`
	CourseID       int64       `json:"course_id"`
	UserName       pgtype.Text `json:"user_name"`
	FirstName      pgtype.Text `json:"first_name"`
	LastName       pgtype.Text `json:"last_name"`
	Active         bool        `json:"active"`
	Pending        bool        `json:"pending"`
	Progress       pgtype.Int8 `json:"progress"`
	Title          pgtype.Text `json:"title"`
}

func (q *Queries) GetSubscriptionByUser(ctx context.Context, arg GetSubscriptionByUserParams) (GetSubscriptionByUserRow, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByUser, arg.UserID, arg.CourseID)
	var i GetSubscriptionByUserRow
	err := row.Scan(
		&i.SubscriptionID,
		&i.UserID,
		&i.CourseID,
		&i.UserName,
		&i.FirstName,
		&i.LastName,
		&i.Active,
		&i.Pending,
		&i.Progress,
		&i.Title,
	)
	return i, err
}

const getTotalSubscribedUserCount = `-- name: GetTotalSubscribedUserCount :one
SELECT COUNT(*) 
FROM Subscriptions
WHERE active = $1
`

func (q *Queries) GetTotalSubscribedUserCount(ctx context.Context, active bool) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalSubscribedUserCount, active)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserCountForCertianCourse = `-- name: GetUserCountForCertianCourse :one
SELECT COUNT(DISTINCT user_id) 
FROM subscriptions
WHERE 
    active = $1
    AND course_id = $2
`

type GetUserCountForCertianCourseParams struct {
	Active   bool  `json:"active"`
	CourseID int64 `json:"course_id"`
}

func (q *Queries) GetUserCountForCertianCourse(ctx context.Context, arg GetUserCountForCertianCourseParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUserCountForCertianCourse, arg.Active, arg.CourseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listSubscriptionsByCourse = `-- name: ListSubscriptionsByCourse :many
SELECT subscription_id, user_id, course_id, active, pending, created_at, updated_at FROM subscriptions
WHERE user_id = $1
ORDER BY course_id
LIMIT $2
OFFSET $3
`

type ListSubscriptionsByCourseParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSubscriptionsByCourse(ctx context.Context, arg ListSubscriptionsByCourseParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByCourse, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.UserID,
			&i.CourseID,
			&i.Active,
			&i.Pending,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByUser = `-- name: ListSubscriptionsByUser :many
SELECT subscription_id, user_id, course_id, active, pending, created_at, updated_at FROM subscriptions
WHERE course_id = $1
ORDER BY user_id
LIMIT $2
OFFSET $3
`

type ListSubscriptionsByUserParams struct {
	CourseID int64 `json:"course_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

func (q *Queries) ListSubscriptionsByUser(ctx context.Context, arg ListSubscriptionsByUserParams) ([]Subscription, error) {
	rows, err := q.db.Query(ctx, listSubscriptionsByUser, arg.CourseID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.UserID,
			&i.CourseID,
			&i.Active,
			&i.Pending,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptions = `-- name: UpdateSubscriptions :one
UPDATE subscriptions
SET 
    pending = COALESCE($1, pending),
    active = COALESCE($2, active)

WHERE
    user_id = $3 AND course_id = $4
RETURNING subscription_id, user_id, course_id, active, pending, created_at, updated_at
`

type UpdateSubscriptionsParams struct {
	Pending  pgtype.Bool `json:"pending"`
	Active   pgtype.Bool `json:"active"`
	UserID   int64       `json:"user_id"`
	CourseID int64       `json:"course_id"`
}

func (q *Queries) UpdateSubscriptions(ctx context.Context, arg UpdateSubscriptionsParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, updateSubscriptions,
		arg.Pending,
		arg.Active,
		arg.UserID,
		arg.CourseID,
	)
	var i Subscription
	err := row.Scan(
		&i.SubscriptionID,
		&i.UserID,
		&i.CourseID,
		&i.Active,
		&i.Pending,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
