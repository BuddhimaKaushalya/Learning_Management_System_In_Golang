// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: submission.sql

package db

import (
	"context"
	"time"
)

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submission (
    assignment_id,
    user_id,
    grade,
    resource,
    date_of_submission,
    submitted
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING submission_id, assignment_id, user_id, submitted, grade, resource, date_of_submission, updated_at
`

type CreateSubmissionParams struct {
	AssignmentID     int64     `json:"assignment_id"`
	UserID           int64     `json:"user_id"`
	Grade            string    `json:"grade"`
	Resource         string    `json:"resource"`
	DateOfSubmission time.Time `json:"date_of_submission"`
	Submitted        bool      `json:"submitted"`
}

func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, createSubmission,
		arg.AssignmentID,
		arg.UserID,
		arg.Grade,
		arg.Resource,
		arg.DateOfSubmission,
		arg.Submitted,
	)
	var i Submission
	err := row.Scan(
		&i.SubmissionID,
		&i.AssignmentID,
		&i.UserID,
		&i.Submitted,
		&i.Grade,
		&i.Resource,
		&i.DateOfSubmission,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSubmission = `-- name: DeleteSubmission :exec
DELETE FROM submission
WHERE 
    assignment_id = $1
    AND user_id = $2
`

type DeleteSubmissionParams struct {
	AssignmentID int64 `json:"assignment_id"`
	UserID       int64 `json:"user_id"`
}

func (q *Queries) DeleteSubmission(ctx context.Context, arg DeleteSubmissionParams) error {
	_, err := q.db.Exec(ctx, deleteSubmission, arg.AssignmentID, arg.UserID)
	return err
}

const getSubmission = `-- name: GetSubmission :one
SELECT submission_id, assignment_id, user_id, submitted, grade, resource, date_of_submission, updated_at FROM submission
WHERE assignment_id = $1 AND user_id = $2
`

type GetSubmissionParams struct {
	AssignmentID int64 `json:"assignment_id"`
	UserID       int64 `json:"user_id"`
}

func (q *Queries) GetSubmission(ctx context.Context, arg GetSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, getSubmission, arg.AssignmentID, arg.UserID)
	var i Submission
	err := row.Scan(
		&i.SubmissionID,
		&i.AssignmentID,
		&i.UserID,
		&i.Submitted,
		&i.Grade,
		&i.Resource,
		&i.DateOfSubmission,
		&i.UpdatedAt,
	)
	return i, err
}

const getsubmissionsByAssignment = `-- name: GetsubmissionsByAssignment :one
SELECT submission_id, assignment_id, user_id, submitted, grade, resource, date_of_submission, updated_at FROM submission
WHERE assignment_id = $1 
LIMIT 1
`

func (q *Queries) GetsubmissionsByAssignment(ctx context.Context, assignmentID int64) (Submission, error) {
	row := q.db.QueryRow(ctx, getsubmissionsByAssignment, assignmentID)
	var i Submission
	err := row.Scan(
		&i.SubmissionID,
		&i.AssignmentID,
		&i.UserID,
		&i.Submitted,
		&i.Grade,
		&i.Resource,
		&i.DateOfSubmission,
		&i.UpdatedAt,
	)
	return i, err
}

const getsubmissionsByUser = `-- name: GetsubmissionsByUser :one
SELECT submission_id, assignment_id, user_id, submitted, grade, resource, date_of_submission, updated_at FROM submission
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetsubmissionsByUser(ctx context.Context, userID int64) (Submission, error) {
	row := q.db.QueryRow(ctx, getsubmissionsByUser, userID)
	var i Submission
	err := row.Scan(
		&i.SubmissionID,
		&i.AssignmentID,
		&i.UserID,
		&i.Submitted,
		&i.Grade,
		&i.Resource,
		&i.DateOfSubmission,
		&i.UpdatedAt,
	)
	return i, err
}

const listsubmissions = `-- name: Listsubmissions :many
SELECT submission_id, assignment_id, user_id, submitted, grade, resource, date_of_submission, updated_at FROM submission
ORDER BY submission_id
LIMIT $1
OFFSET $2
`

type ListsubmissionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) Listsubmissions(ctx context.Context, arg ListsubmissionsParams) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listsubmissions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Submission{}
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.SubmissionID,
			&i.AssignmentID,
			&i.UserID,
			&i.Submitted,
			&i.Grade,
			&i.Resource,
			&i.DateOfSubmission,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubmission = `-- name: UpdateSubmission :one
UPDATE submission
SET assignment_id = $2 AND user_id = $3
WHERE submission_id = $1
RETURNING submission_id, assignment_id, user_id, submitted, grade, resource, date_of_submission, updated_at
`

type UpdateSubmissionParams struct {
	SubmissionID int64 `json:"submission_id"`
	AssignmentID int64 `json:"assignment_id"`
	UserID       int64 `json:"user_id"`
}

func (q *Queries) UpdateSubmission(ctx context.Context, arg UpdateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, updateSubmission, arg.SubmissionID, arg.AssignmentID, arg.UserID)
	var i Submission
	err := row.Scan(
		&i.SubmissionID,
		&i.AssignmentID,
		&i.UserID,
		&i.Submitted,
		&i.Grade,
		&i.Resource,
		&i.DateOfSubmission,
		&i.UpdatedAt,
	)
	return i, err
}
