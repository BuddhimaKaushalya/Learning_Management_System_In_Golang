// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: courses.sql

package db

import (
	"context"
	"eduApp/typetext"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCourses = `-- name: CreateCourses :one
INSERT INTO courses (
    user_id,
    title,
    description,
    image,
    catagory,
    what_will,
    sequential_access
    
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING course_id, user_id, title, description, image, catagory, what_will, sequential_access, created_at, updated_at
`

type CreateCoursesParams struct {
	UserID           int64  `json:"user_id"`
	Title            string `json:"title"`
	Description      string `json:"description"`
	Image            string `json:"image"`
	Catagory         string `json:"catagory"`
	WhatWill         typetext.WhatWill `json:"what_will"`
	SequentialAccess bool   `json:"sequential_access"`
}

func (q *Queries) CreateCourses(ctx context.Context, arg CreateCoursesParams) (Course, error) {
	row := q.db.QueryRow(ctx, createCourses,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Image,
		arg.Catagory,
		arg.WhatWill,
		arg.SequentialAccess,
	)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Image,
		&i.Catagory,
		&i.WhatWill,
		&i.SequentialAccess,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCourses = `-- name: DeleteCourses :exec
DELETE FROM courses
WHERE course_id = $1
`

func (q *Queries) DeleteCourses(ctx context.Context, courseID int64) error {
	_, err := q.db.Exec(ctx, deleteCourses, courseID)
	return err
}

const getCourseByUserID = `-- name: GetCourseByUserID :one
SELECT course_id, user_id, title, description, image, catagory, what_will, sequential_access, created_at, updated_at FROM courses
WHERE user_id = $1
`

func (q *Queries) GetCourseByUserID(ctx context.Context, userID int64) (Course, error) {
	row := q.db.QueryRow(ctx, getCourseByUserID, userID)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Image,
		&i.Catagory,
		&i.WhatWill,
		&i.SequentialAccess,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourses = `-- name: GetCourses :one
SELECT course_id, user_id, title, description, image, catagory, what_will, sequential_access, created_at, updated_at FROM courses
WHERE course_id = $1
`

func (q *Queries) GetCourses(ctx context.Context, courseID int64) (Course, error) {
	row := q.db.QueryRow(ctx, getCourses, courseID)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Image,
		&i.Catagory,
		&i.WhatWill,
		&i.SequentialAccess,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEntireCourse = `-- name: GetEntireCourse :one
SELECT 
    c.course_id, c.user_id, c.title, c.description, c.image, c.catagory, c.what_will, c.sequential_access, c.created_at, c.updated_at,
    COALESCE(json_agg(DISTINCT m) FILTER (WHERE m.material_id IS NOT NULL), '[]') AS material,
    COALESCE(json_agg(DISTINCT a) FILTER (WHERE a.assignment_id IS NOT NULL), '[]') AS assignment
FROM 
    courses c
LEFT JOIN 
    material m ON c.course_id = m.course_id
LEFT JOIN 
    assignment a ON c.course_id = a.course_id
WHERE 
    c.course_id = $1
GROUP BY 
    c.course_id
LIMIT 1
`

type GetEntireCourseRow struct {
	CourseID         int64       `json:"course_id"`
	UserID           int64       `json:"user_id"`
	Title            string      `json:"title"`
	Description      string      `json:"description"`
	Image            string      `json:"image"`
	Catagory         string      `json:"catagory"`
	WhatWill         []byte      `json:"what_will"`
	SequentialAccess bool        `json:"sequential_access"`
	CreatedAt        time.Time   `json:"created_at"`
	UpdatedAt        time.Time   `json:"updated_at"`
	Material         interface{} `json:"material"`
	Assignment       interface{} `json:"assignment"`
}

func (q *Queries) GetEntireCourse(ctx context.Context, courseID int64) (GetEntireCourseRow, error) {
	row := q.db.QueryRow(ctx, getEntireCourse, courseID)
	var i GetEntireCourseRow
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Image,
		&i.Catagory,
		&i.WhatWill,
		&i.SequentialAccess,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Material,
		&i.Assignment,
	)
	return i, err
}

const getTotalCourseCount = `-- name: GetTotalCourseCount :one
SELECT COUNT(*) 
FROM courses
`

func (q *Queries) GetTotalCourseCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalCourseCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listAllCourseByCatagory = `-- name: ListAllCourseByCatagory :many
SELECT  
    course_id,
    user_id,
    title,
    description,
    image,
    catagory,
    created_at,
    what_will,
    updated_at
FROM courses
WHERE catagory = $1
ORDER BY course_id
LIMIT 100
`

type ListAllCourseByCatagoryRow struct {
	CourseID    int64     `json:"course_id"`
	UserID      int64     `json:"user_id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Image       string    `json:"image"`
	Catagory    string    `json:"catagory"`
	CreatedAt   time.Time `json:"created_at"`
	WhatWill    typetext.WhatWill   `json:"what_will"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) ListAllCourseByCatagory(ctx context.Context, catagory string) ([]ListAllCourseByCatagoryRow, error) {
	rows, err := q.db.Query(ctx, listAllCourseByCatagory, catagory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllCourseByCatagoryRow{}
	for rows.Next() {
		var i ListAllCourseByCatagoryRow
		if err := rows.Scan(
			&i.CourseID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Image,
			&i.Catagory,
			&i.CreatedAt,
			&i.WhatWill,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllCourseCatagories = `-- name: ListAllCourseCatagories :many
SELECT DISTINCT  
    catagory
FROM courses
LIMIT 20
`

func (q *Queries) ListAllCourseCatagories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listAllCourseCatagories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var catagory string
		if err := rows.Scan(&catagory); err != nil {
			return nil, err
		}
		items = append(items, catagory)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCourses = `-- name: ListCourses :many
SELECT course_id, user_id, title, description, image, catagory, what_will, sequential_access, created_at, updated_at FROM courses
ORDER BY course_id
LIMIT $1
OFFSET $2
`

type ListCoursesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCourses(ctx context.Context, arg ListCoursesParams) ([]Course, error) {
	rows, err := q.db.Query(ctx, listCourses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Course{}
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.CourseID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Image,
			&i.Catagory,
			&i.WhatWill,
			&i.SequentialAccess,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCourses = `-- name: UpdateCourses :one
UPDATE courses
SET  
       title = COALESCE($1, title),
       image = COALESCE($2, image),
       description = COALESCE($3, description),
       catagory = COALESCE($4, catagory),
        sequential_access = COALESCE($5, sequential_access),
         what_will = COALESCE($6, what_will)

WHERE  course_id = $7
RETURNING course_id, user_id, title, description, image, catagory, what_will, sequential_access, created_at, updated_at
`

type UpdateCoursesParams struct {
	Title            pgtype.Text `json:"title"`
	Image            pgtype.Text `json:"image"`
	Description      pgtype.Text `json:"description"`
	Catagory         pgtype.Text `json:"catagory"`
	SequentialAccess pgtype.Bool `json:"sequential_access"`
	WhatWill         typetext.WhatWill `json:"what_will"`
	CourseID         int64       `json:"course_id"`
}

func (q *Queries) UpdateCourses(ctx context.Context, arg UpdateCoursesParams) (Course, error) {
	row := q.db.QueryRow(ctx, updateCourses,
		arg.Title,
		arg.Image,
		arg.Description,
		arg.Catagory,
		arg.SequentialAccess,
		arg.WhatWill,
		arg.CourseID,
	)
	var i Course
	err := row.Scan(
		&i.CourseID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Image,
		&i.Catagory,
		&i.WhatWill,
		&i.SequentialAccess,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
